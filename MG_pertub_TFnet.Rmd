Load the required R libraries

```{r eval=FALSE}

# load R packages
library(Seurat)
library(ggplot2)
library(cowplot)
library(viridis)
library(dplyr)
library(tictoc)
library(Matrix)
library(hdWGCNA)
theme_set(theme_cowplot())

# RNA velocity packages that we need for some helper functions
options(warn=-1)
library(velocyto.R)
library(velociraptor)

# re-install hdWGCNA
# devtools::install_github('smorabit/hdWGCNA', ref='dev')

# load the perturbation functions 
source('/dfs7/swaruplab/smorabit/analysis/scWGCNA/perturb/bin/perturbation_functions.R')
source('/dfs7/swaruplab/smorabit/analysis/scWGCNA/perturb/bin/TF_functions.R')

# spatial plotting functions (not sure if needed here)
source('/dfs7/swaruplab/smorabit/analysis/scWGCNA/bin/spatial_functions.R')

# output directories
setwd('/dfs7/swaruplab/smorabit/analysis/scWGCNA/perturb/')
data_dir <- "data/"
fig_dir <- 'figures/'

# re-load MG dataset
seurat_mg <- readRDS(file='/dfs7/swaruplab/smorabit/analysis/scWGCNA/microglia/data/AD_MG_scWGCNA.rds')

# update the path to the hdWGCNA TOM
net <- GetNetworkData(seurat_mg)
net$TOMFiles <- '/dfs7/swaruplab/smorabit/analysis/scWGCNA/microglia/TOM/_ConsensusTOM-block.1.rda'
seurat_mg <- SetNetworkData(seurat_mg, net)

# make a cell neighborhood graph:
seurat_mg <- FindNeighbors(seurat_mg, reduction='harmony')
seurat_obj <- seurat_mg

# load AD dataset (Morabito, Mathys, and Zhou integrated)
#seurat_AD <- readRDS(file="/dfs7/swaruplab/smorabit/analysis/ADDS_2021/splitseq/integration/data/AD_integrated.rds" )

```

hdWGCNA motif scan

```{r eval=FALSE}


# for motif analysis 
library(JASPAR2020)
library(motifmatchr)
library(TFBSTools)
library(EnsDb.Hsapiens.v86)
library(BSgenome.Hsapiens.UCSC.hg38)
library(GenomicRanges)

pfm_core <- TFBSTools::getMatrixSet(
  x = JASPAR2020,
  opts = list(collection = "CORE", tax_group = 'vertebrates', all_versions = FALSE)
)

# run the motif scan with these settings for the mouse dataset
seurat_obj <- MotifScan(
  seurat_obj,
  species_genome = 'hg38',
  pfm = pfm_core,
  EnsDb = EnsDb.Hsapiens.v86
)

```

Run the XGBoost TF network construction function 

```{r eval=FALSE}

library(xgboost)
library(tictoc)

motif_matrix <- GetMotifMatrix(seurat_obj)
motif_df <- GetMotifs(seurat_obj)
motif_df <- subset(motif_df, gene_name %in% rownames(seurat_obj))

# set up XGBoost model parameters
model_params <- list(
  objective = 'reg:squarederror',
  max_depth = 1,
  eta = 0.1,
  nthread=16,
  alpha=0.5,
  n_estimators=50
)
nfold=5

#---------------------------------------------------------------------------
# Set the expression matrix that we will use for the TF network analysis
#---------------------------------------------------------------------------

modules <- GetModules(seurat_obj)

# this should be before we SetDatExpr
wgcna_genes <- GetWGCNAGenes(seurat_obj)
genes_use <- wgcna_genes[wgcna_genes %in% rownames(motif_matrix)]
genes_use <- unique(c(genes_use, motif_df$gene_name))
seurat_obj <- SetWGCNAGenes(seurat_obj, genes_use)

seurat_obj <- SetDatExpr(seurat_obj)
datExpr <- GetDatExpr(seurat_obj)

#---------------------------------------------------------------------------
# Construct the TF net
#---------------------------------------------------------------------------

seurat_obj <- ConstructTFNetwork(
    seurat_obj,
    model_params=list(
        objective = 'reg:squarederror',
        max_depth = 1,
        eta = 0.1,
        nthread=16,
        alpha=0.5,
        n_estimators=50
    ),
    wgcna_name = 'MG'
)

#---------------------------------------------------------------------------
# Assign TF regulons
#---------------------------------------------------------------------------

seurat_obj <- AssignTFRegulons(
    seurat_obj,
    strategy = "A",
    reg_thresh = 0.01,
    n_tfs = 10
)
tf_regulons <- GetTFRegulons(seurat_obj)


#---------------------------------------------------------------------------
# Compute positive and negative regulon scores
#---------------------------------------------------------------------------

# positive regulons
seurat_obj <- RegulonScores(
    seurat_obj,
    target_type = 'positive',
    ncores=8
)

# negative regulons
seurat_obj <- RegulonScores(
    seurat_obj,
    target_type = 'negative',
    cor_thresh = -0.05,
    ncores=8
)
regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive')
head(regulon_scores)



# save the seurat obj with this info
saveRDS(seurat_obj, file=paste0(data_dir, 'AD_MG_hdWGCNA_tfs.rds'))





# only run the network analysis on genes that are not in the
# grey module
# genes_notgrey <- subset(modules, module != 'grey') %>% .$gene_name
# genes_notgrey <- genes_notgrey[genes_notgrey %in% colnames(datExpr)]
# datExpr <- datExpr[,genes_notgrey]
# seurat_obj <- SetDatExpr(seurat_obj, group_name='ass', assay='RNA', mat=datExpr)
# datExpr <- GetDatExpr(seurat_obj)



# datExpr <- GetDatExpr(seurat_obj)
# dim(datExpr)

# datExpr_sub <- datExpr[,floor(ncol(datExpr)*0.94):ncol(datExpr)]
# seurat_obj@misc$MHb_metacell$datExpr <- datExpr_sub

# this did not work lmao
# test <- ConstructTFNetwork(
#   seurat_obj,
#   model_params=model_params
# )
# importance_df <- test[[1]]
# eval_df <- test[[2]]

# # save the results:
# write.csv(importance_df, file=paste0(data_dir, 'MG_tf_xgboost.csv'), quote=FALSE, row.names=FALSE)
# write.csv(eval_df, file=paste0(data_dir, 'MG_tf_xgboost_eval.csv'), quote=FALSE, row.names=FALSE)

# # add to Seurat object:
# seurat_obj <- SetTFNetwork(seurat_obj, importance_df, wgcna_name=wgcna_name)
# seurat_obj <- SetTFEval(seurat_obj, eval_df, wgcna_name=wgcna_name)


```

Assign regulons 

Assigning TF regulons like they did in the SCENIC paper (GENIE3 Methods section).

For all strategies, only TFs with importance > 0.001 were counted.

Strategy 1. Set an importance threshold (> 0.001 and > 0.005).
Strategy 2. Take the top 50 target genes with the highest importance for each TF.
Strategy 3. Keep only the top 5,10, and 50 TFs for each target gene, then split by TF.

Should we split into + / - correlation before applying the strategies?

Should we make this it's own function>?

```{r eval=FALSE}

seurat_obj <- AssignTFRegulons(
    seurat_obj,
    strategy = "A",
    reg_thresh = 0.1,
    n_tfs = 5
)
tf_regulons <- GetTFRegulons(seurat_obj)


# positive regulons
seurat_obj <- RegulonScores(
    seurat_obj,
    target_type = 'positive',
    ncores=8
)

# negative regulons
seurat_obj <- RegulonScores(
    seurat_obj,
    target_type = 'negative',
    cor_thresh = -0.05,
    ncores=8
)
regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive')
head(regulon_scores)



# save the seurat obj with this info
saveRDS(seurat_obj, file=paste0(data_dir, 'AD_MG_hdWGCNA_tfs.rds'))


# plot the + and - SPI1 regulons 

cur_tf <- 'SPI1'
pos_regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive')
neg_regulon_scores <- GetRegulonScores(seurat_obj, target_type='negative')

seurat_obj$SPI1_pos <- pos_regulon_scores[,cur_tf]
seurat_obj$SPI1_neg <- neg_regulon_scores[,cur_tf]


  p1 <- FeatureEmbedding(
    seurat_obj,
    features='SPI1_pos',
    #reduction='neuron_umap',
    plot_max=0.4,
    plot_min=0.05,
    ncol=2,
    dpi=300,
    point_size=0.25,
    dpi_scale=0.25,
    order_points='shuffle',
  ) 


  p2 <- FeatureEmbedding(
    seurat_obj,
    features='SPI1_neg',
    #reduction='neuron_umap',
    plot_max=0.4,
    plot_min=0.05,
    ncol=2,
    dpi=300,
    point_size=0.25,
    dpi_scale=0.25,
    order_points='shuffle',
  ) 


pdf(paste0(fig_dir, 'test_spi1_regulon.pdf'), width=6, height=3)
(p1 | p2) + plot_layout(guides='collect')
dev.off()



```


Test making a network plot using tidygraph + ggraph 

```{r eval=FALSE}

library(ggraph)
library(tidygraph)
library(igraph)

cur_tf <- 'TCF4'


# get the regulons
regulons <- GetTFRegulons(seurat_obj)

# compute the degree for each TF:
tf_degrees <- table(regulons$tf)

#---------------------------------------------------------------------------#
# Get the primary & secondary targets of the cur tf
#---------------------------------------------------------------------------#

# primary target genes 
cur_primary<- regulons %>% 
subset(tf == cur_tf) 

# which of these pimary target genes are tfs?
cur_primary_tfs <- cur_primary %>% 
subset(gene %in% unique(regulons$tf)) %>% .$gene

cur_tfs <- unique(c(cur_tf, cur_primary_tfs))

# get the regulons for these TFs:
cur_secondary <- subset(regulons, tf %in% cur_primary_tfs)
cur_secondary_tfs <- cur_primary %>% 
subset(gene %in% unique(regulons$tf)) %>% .$gene

# combine the primary and secondary into one table 
cur_network <- rbind(cur_primary, cur_secondary)
cur_network$Gain <- cur_network$Gain * sign(cur_network$Cor)

cur_genes <- unique(cur_network$gene)
length(cur_genes)

# make an igraph network from the nr4a2 regulon:
cur_network <- cur_network %>%
dplyr::rename(c(source=tf, target=gene)) %>%
mutate(Score = sign(Cor) * Gain)

primary_genes <- unique(cur_primary$gene)
secondary_genes <- unique(cur_network$target[! cur_network$target %in% primary_genes])

# cutoff for correlation values
cor_cutoff <- 0.75
cur_network$Cor <- ifelse(abs(cur_network$Cor) > cor_cutoff, sign(cur_network$Cor) * cor_cutoff, cur_network$Cor)

#---------------------------------------------------------------------------#
# Plot with ggraph
#---------------------------------------------------------------------------#

graph <- as_tbl_graph(cur_network) %>% 
activate(nodes) %>% 
mutate(degree  = centrality_degree())  

tmp <- tf_degrees[names(V(graph))]; tmp <- tmp[!is.na(tmp)]
V(graph)[names(tmp)]$degree <- as.numeric(tmp)

V(graph)$gene_type <- ifelse(names(V(graph)) %in% unique(regulons$tf), 'TF', 'Gene')
V(graph)$gene_type <- ifelse(names(V(graph)) == cur_tf, cur_tf, V(graph)$gene_type)

set.seed(12345)
n_pivots <- 250
if(length(V(graph)) < n_pivots){
n_pivots <- length(V(graph)) / 2
}
lay <- create_layout(graph, layout='sparse_stress', pivots=n_pivots)

#lay <- create_layout(graph, layout='focus', focus = node_is_center())

# add extra info
# lay$tf_name <- ifelse(lay$name %in% unique(regulons$tf), lay$name, NA)
lay$tf_name <- ifelse(lay$name %in% c(cur_tf, cur_primary_tfs), lay$name, NA)
lay$size <- ifelse(lay$name %in% unique(regulons$tf), 5, 2)
lay$type <- ifelse(lay$name %in% primary_genes, 'Primary', 'Secondary')
lay$type <- ifelse(lay$name == cur_tf, cur_tf, lay$type)
lay$type <- factor(lay$type, levels = c(cur_tf, 'Primary', 'Secondary'))

# shape layout:
cur_shapes <- c(18, 17, 16); names(cur_shapes) <- c(cur_tf, 'TF', 'Gene')

p <- ggraph(lay) + 
geom_edge_link(
    aes(color=Cor, alpha=abs(Cor)),
    arrow = arrow(length = unit(1, 'mm'), type='closed'), 
                # size=0.5,
                # end_cap = circle(3, 'mm')
) + 
geom_node_point(data=subset(lay, (! name %in% regulons$tf) | name == cur_tf ), aes(color=type, shape=gene_type, size=degree)) +
geom_node_point(data=subset(lay, name %in% regulons$tf & name != cur_tf), aes(fill=type, size=degree), color='black', shape=25) +

# ggrastr::rasterise(geom_node_point(aes(color=type, size=degree)), dpi=200) +
#geom_node_text(aes(label=tf_name), repel=TRUE, max.overlaps=Inf, fontface='italic') +
geom_node_label(aes(label=tf_name), repel=TRUE, max.overlaps=Inf, fontface='italic') +
scale_edge_colour_gradient2(high='orange2', mid='white', low='dodgerblue')  + 
scale_colour_manual(values=c('black', 'darkorchid4', 'mediumpurple2')) + 
scale_fill_manual(values=c('darkorchid4', 'mediumpurple2')) + 
scale_shape_manual(values=cur_shapes) 

pdf(paste0(fig_dir, 'TFnetwork_',cur_tf, '.pdf'), width=8, height=7)
print(p)
dev.off()



p <- ggraph(lay) + 
geom_edge_link(
    aes(color=Cor, alpha=abs(Cor)),
    arrow = arrow(length = unit(1, 'mm'), type='closed'), 
                # size=0.5,
                # end_cap = circle(3, 'mm')
) + 
geom_node_point(data=subset(lay, (! name %in% regulons$tf) | name == cur_tf ), aes(color=type, shape=gene_type, size=degree)) +
geom_node_point(data=subset(lay, name %in% regulons$tf & name != cur_tf), aes(fill=type, size=degree), color='black', shape=25) +
scale_edge_colour_gradient2(high='orange2', mid='white', low='dodgerblue')  + 
scale_colour_manual(values=c('black', 'darkorchid4', 'mediumpurple2')) + 
scale_fill_manual(values=c('darkorchid4', 'mediumpurple2')) + 
scale_shape_manual(values=cur_shapes) + NoLegend()

pdf(paste0(fig_dir, 'TFnetwork_',cur_tf, '_nolabel.pdf'), width=5, height=5)
print(p)
dev.off()


```


Quantify the number of TF links between modules and plot as a heamap

```{r eval=FALSE}

modules <- GetModules(seurat_obj)
mods <- levels(modules$module); mods <- mods[mods != 'grey']
tf_list <- unique(tf_regulons$tf)
module_tfs <- subset(modules, gene_name %in% tf_list)

tf_regulons <- subset(regulons, tf %in% module_tfs$gene_name & gene %in% module_tfs$gene_name)
ix <- match(tf_regulons$tf, modules$gene_name)
tf_regulons$source_module <- modules$module[ix]
ix <- match(tf_regulons$gene, modules$gene_name)
tf_regulons$target_module <- modules$module[ix]
tf_regulons %<>% dplyr::rename(source=tf, target=gene) %>% mutate(Gain = Gain * sign(Cor))
cur_network <- tf_regulons

# add module info to the network:
ix <- match(cur_network$source, modules$gene_name)
cur_network$source_module <- modules$module[ix]
ix <- match(cur_network$target, modules$gene_name)
cur_network$target_module <- modules$module[ix]

# make empty matrices to store the number of links between mods
pos_mat <- matrix(0, length(mods), length(mods))
rownames(pos_mat) <- mods; colnames(pos_mat) <- mods
neg_mat <- matrix(0, length(mods), length(mods))
rownames(neg_mat) <- mods; colnames(neg_mat) <- mods

# loop through combos of mods and identify the number of +/- links between mods
combos <- expand.grid(mods, mods)
for(i in 1:nrow(combos)){
  m1 <- as.character(combos[i,'Var1'])
  m2 <- as.character(combos[i, 'Var2'])

  # how many positive connections from m1 to m2:
  cur_pos <- subset(cur_network, target_module == m1 & source_module == m2 & Gain >= 0)
  cur_neg <- subset(cur_network, target_module == m1 & source_module == m2 & Gain < 0)

  if(m1 == m2){
    pos_mat[m1,m2] <- 0
    neg_mat[m1,m2] <- 0
  } else{
    pos_mat[m1,m2] <- nrow(cur_pos)
    neg_mat[m1,m2] <- nrow(cur_neg)
  }

}

max_val <- 1
plot_df <- reshape2::melt(neg_mat)
plot_df$count <-plot_df$value
plot_df$label <- ifelse(plot_df$value > 5, plot_df$value, "")
tmp <-table(module_tfs$module)
ix <- match(plot_df$Var1, names(tmp))
plot_df$value <- plot_df$value / as.numeric(tmp)[ix]
plot_df1 <- plot_df

plot_df$value <- ifelse(plot_df$value > max_val, max_val, plot_df$value)
p1 <- plot_df %>% 
  ggplot(aes(x=Var1, y=fct_rev(Var2), fill=value)) + 
  geom_tile() + 
  geom_text(aes(label=label)) +
  scale_fill_gradient(low='grey95', high='dodgerblue') + 
  coord_fixed() + RotatedAxis() + 
  xlab('Target') + ylab('Source') + 
  ggtitle('Repressive interactions') + 
  theme(
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    panel.border = element_rect(linewidth=1, fill=NA, color='black')
  )


plot_df <- reshape2::melt(pos_mat)
plot_df$count <-plot_df$value
plot_df$label <- ifelse(plot_df$value > 5, plot_df$value, "")

tmp <-table(module_tfs$module)
ix <- match(plot_df$Var1, names(tmp))
plot_df$value <- plot_df$value / as.numeric(tmp)[ix]
plot_df2 <- plot_df

plot_df$value <- ifelse(plot_df$value > max_val, max_val, plot_df$value)
p2 <- plot_df %>% 
  ggplot(aes(x=Var1, y=fct_rev(Var2), fill=value)) + 
  geom_tile() + 
  geom_text(aes(label=label)) +
  scale_fill_gradient(low='grey95', high='orange2') + 
  coord_fixed() + RotatedAxis()  + 
  xlab('Target') + ylab('Source') + 
  ggtitle('Activating interactions') + 
  theme(
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    panel.border = element_rect(linewidth=1, fill=NA, color='black')
  )


pdf(paste0(fig_dir,'test_network_interactions_heatmap_norm.pdf'), width=7, height=4)
p1 + p2 + plot_layout(guides='collect')
dev.off()

#---------------------------------------------------------------------------#
# Delta of Activating / Repressive interactions
#---------------------------------------------------------------------------#

plot_df1$delta <-  plot_df2$value - plot_df1$value

p3 <- plot_df1 %>% 
  ggplot(aes(x=Var1, y=fct_rev(Var2), fill=delta)) + 
  geom_tile() + 
  #geom_text(aes(label=label)) +
  scale_fill_gradient2(low='dodgerblue', mid='grey95', high='orange2') + 
  coord_fixed() + RotatedAxis()  + 
  xlab('Target') + ylab('Source') + 
  ggtitle('Activating - repressing') + 
  theme(
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    panel.border = element_rect(linewidth=1, fill=NA, color='black')
  )


pdf(paste0(fig_dir,'test_network_interactions_heatmap_norm_delta.pdf'), width=4, height=10)
p1 / p2 / p3 
dev.off()


```





TF Network perturbation 

Do I need to treat the +/- regulons the same?
Yes

```{r eval=FALSE}

# re-load dataset:
seurat_obj <- readRDS(file=paste0(data_dir, 'AD_MG_hdWGCNA_tfs.rds'))

library(igraph)

# options
cur_tf = 'TCF4'

cur_tf = 'SPI1'
slot = 'counts'
assay = 'RNA'
perturb_dir = -1
delta_scale = 1
n_iters = 3
perturbation_name = 'SPI1_down'
corr_sigma=0.05
n_threads=4
graph = 'RNA_nn'


# set up the TF network
tf_regulons <- GetTFRegulons(seurat_obj)
tfs <- unique(tf_regulons$tf)
modules <- GetModules(seurat_obj)
tf_modules <- subset(modules, gene_name %in% tfs & module != 'grey')

tmp <- tf_regulons # %>% subset(Cor > 0)
tmp$Gain <- tmp$Gain * sign(tmp$Cor)
tmp <- tmp[,1:3]
names(tmp) <- c('source', 'target', 'value')

# convert to igraph
g <- igraph::graph_from_data_frame(
  tmp, 
  directed=TRUE, 
  #vertices=vertex_df
)

# get adjacency matrix:
adj <- igraph::as_adjacency_matrix(g, attr='value')
tfnet_genes <- rownames(adj)

TOM <- GetTOM(seurat_mg, wgcna_name)
tfnet_genes <- tfnet_genes[tfnet_genes %in% rownames(TOM)]
cur_TOM <- TOM[tfnet_genes, tfnet_genes]
adj <- adj[tfnet_genes, tfnet_genes]

# transpose the matrix:
adj <- t(adj)

# get cell barcodes:
cells_use <- colnames(seurat_obj)

# apply the perturbation
exp <- GetAssayData(seurat_obj, slot=slot, assay = assay)

exp_per <- ApplyPerturbation(
    seurat_obj,
    exp,
    features = cur_tf,
    perturb_dir = perturb_dir,
    cells_use = cells_use,
    # group.by = group.by,
    # group_name = group_name,
    slot = slot,
    assay = assay
)

# need to open up this function and see what's going on under the hood...
print('Applying signal propagation throughout co-expression network...')
exp_prop <- ApplyPropagation(
    seurat_obj,
    exp[tfnet_genes,cells_use],
    exp_per[tfnet_genes,cells_use],
    network = adj,
    #network = cur_TOM,
    perturb_dir = perturb_dir,
    delta_scale = delta_scale,
    n_iters = 1
)

if(!all(colnames(seurat_obj) %in% cells_use)){
    exp_prop_other <- exp[module_genes,setdiff(colnames(seurat_obj), cells_use)]
    exp_prop <- cbind(exp_prop, exp_prop_other)
    exp_prop <- exp_prop[,colnames(seurat_obj)]
}


# append the expression matrices:
exp_simulated <- rbind(
    exp_per[!(rownames(exp_per) %in% tfnet_genes),], # genes that aren't in this module
    exp_prop # genes from this module with perturbations
)

# make sure the order matches the original expression matrix
exp_simulated <- exp_simulated[rownames(seurat_obj),colnames(seurat_obj)]

# check for differences?
cur_regulon <- subset(tf_regulons, tf == cur_tf)
cur_regulon_genes <- c( unique(cur_regulon$gene))
cur_X <- exp[cur_regulon_genes,]
cur_X_per <- exp_simulated[cur_regulon_genes,]
all.equal(cur_X_per, cur_X)
all.equal(exp[cur_tf,], exp_simulated[cur_tf,])

# add perturbation assay to the Seurat object:
perturb_assay <- CreateAssayObject(
    exp_simulated,
    assay = perturbation_name
)
seurat_obj[[perturbation_name]] <- perturb_assay

# normalize the perturbation assay
seurat_obj <- NormalizeData(seurat_obj, perturbation_name)

###########################################################################
# Part 3: compute transition probabilities
###########################################################################

# this one took a while
seurat_obj <- PerturbationTransitions(
    seurat_obj,
    perturbation_name,
    features=tfnet_genes,
    graph=graph, 
    #all_features=all_features,
    corr_sigma=corr_sigma,
    n_threads=n_threads,
    slot='data', # should we make this an option?
    assay=assay
)



#-------------------------------------------------------------------------#
# Plotting the result as a vector field plot on top of the UMAP
# (need to makeki8op560m this into proprer functions later)
#-------------------------------------------------------------------------#

# This function gives us the dataframe with vector coordinates 
# (ars) and v.6/df.S_+<Âªector distances (arsd)
vectors <- PerturbationVectors(
  seurat_obj,
  perturbation_name = perturbation_name,
  reduction = 'umap', # default
  arrow_scale = 1 # default
)
ars <- vectors$ars 
arsd <- vectors$arsd

# Get the UMAP embedding from the seurat object 
# and subset to only keep cells that we have arrows for.
emb <- seurat_obj@reductions$umap@cell.embeddings
emb <- emb[rownames(ars),]

# run the velociraptor function to make a grid of arrows instead of one 
# arrow per cell
grid.df <- velociraptor::gridVectors(emb, arsd)


# compute the length of each arrow 
distances <- sqrt(
  ((grid.df$end.xd - grid.df$start.UMAP_1)^2) - 
  ((grid.df$end.yd - grid.df$start.UMAP_2)^2) 
)
distances <- ifelse(is.nan(distances), 0, distances)
grid.df$length <- distances

# make a dataframe to plot with ggplot
plot_df <- as.data.frame(emb)
plot_df$pseudotime <- seurat_obj@meta.data[rownames(emb), 'pseudotime']

# plot the scatter plot
p1 <- ggplot(plot_df, aes(x=UMAP_1, y=UMAP_2, color=pseudotime)) +
  geom_point(alpha=0.25, size=2) +
  scale_color_gradientn(colors=plasma(256))
  
# add the arrows
p1 <- p1 +
  geom_segment(
    data = grid.df,
    inherit.aes=FALSE,
    aes(
      x=start.UMAP_1, 
      y=start.UMAP_2, 
      xend=end.xd, 
      yend=end.yd,
      alpha= length
    ), 
    arrow=grid::arrow(length=unit(0.1, "cm")), size=0.25
  ) +
  scale_alpha_continuous(range=c(0.8,1)) +
  coord_equal() +
  umap_theme() +
  NoLegend() +
  ggtitle(paste0(perturbation_name))

pdf(paste0(fig_dir, 'vectorfield_', perturbation_name, '.pdf'), width=6, height=3)
p1
dev.off()



#-------------------------------------------------------------------------#
# Plotting the regulon & TF expression
#-------------------------------------------------------------------------#

# plot the + and - SPI1 regulons 

pos_regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive')
neg_regulon_scores <- GetRegulonScores(seurat_obj, target_type='negative')

seurat_obj$tf_pos <- pos_regulon_scores[,cur_tf]
seurat_obj$tf_neg <- neg_regulon_scores[,cur_tf]


p2 <- FeatureEmbedding(
    seurat_obj,
    features=cur_tf,
    #reduction='neuron_umap',
   # plot_max=0.4,
    plot_min=0.5,
    ncol=2,
    dpi=300,
    point_size=1,
    dpi_scale=1,
    order_points=TRUE,
) + ggtitle('Expression') 



p3 <- FeatureEmbedding(
    seurat_obj,
    features='tf_pos',
    #reduction='neuron_umap',
    plot_max=0.4,
    plot_min=0.1,
    ncol=2,
    dpi=300,
    point_size=1,
    dpi_scale=1,
    order_points=TRUE,
) + ggtitle('Target score (+)') + 
    scale_color_continuous(low='grey95', high='dodgerblue')


p4 <- FeatureEmbedding(
    seurat_obj,
    features='tf_neg',
    #reduction='neuron_umap',
    plot_max=0.4,
    plot_min=0.1,
    ncol=2,
    dpi=300,
    point_size=1,
    dpi_scale=1,
    order_points=TRUE,
) + ggtitle('Target score (-)') +
    scale_color_continuous(low='grey95', high='orange')


pdf(paste0(fig_dir, 'vectorfield_', perturbation_name, '.pdf'), width=12, height=6)
(p1 + p2) / (p3 + p4)
dev.off()


```

Plot the change in gene expression between observed and 
perturbed for each gene in module M4 vs the kME 

```{r eval=FALSE}

cur_regulon <- subset(tf_regulons, tf == cur_tf)
cur_regulon_genes <- c( unique(cur_regulon$gene))
cur_regulon_genes <- cur_regulon_genes[cur_regulon_genes %in% tfnet_genes]

# get the observed and perturbed expression matrices and compute the deltas
X <- GetAssayData(seurat_obj, assay='RNA', slot='counts')[cur_regulon_genes,]
X_norm <- GetAssayData(seurat_obj, assay='RNA', slot='data')[cur_regulon_genes,]
X_per <- GetAssayData(seurat_obj, assay=perturbation_name, slot='counts')[cur_regulon_genes,]
delta <- X_per - X

# compute the average observed expression for each gene:
avg_exp <- rowSums(X_norm) / ncol(X_norm)

# compute the mean delta value for each gene across all the cells:
plot_df <- reshape2::melt(as.matrix(delta)) 
plot_df <- plot_df%>% 
  group_by(Var1) %>% 
  summarise(delta = mean(value)) %>%
  dplyr::rename(gene = Var1)

# join this df with the kME df
plot_df <- dplyr::left_join(
  x = plot_df,
  y = cur_regulon,
  by = 'gene'
)

# add col for avg exp 
plot_df$avg_exp <- avg_exp

# plot with ggplot
p1 <- plot_df %>% 
  ggplot(aes(x = delta, y = Gain * sign(Cor), size=avg_exp)) + 
  geom_point() + 
  geom_smooth(
    data = plot_df, inherit.aes = FALSE,
    aes(x=delta, y=Gain * sign(Cor)),
    method = 'lm',
    color = 'black'
    ) + 
    ggpubr::stat_cor(
      data = plot_df, inherit.aes = FALSE,
    aes(x=delta, y=Gain * sign(Cor))
    ) + 
    # geom_label_repel(
    #   label=plot_df$label, 
    #   max.overlaps=Inf,
    #   color='black',
    #   size=3
    # ) +
    theme(
      axis.line.x = element_blank(),
      axis.line.y = element_blank(),
      panel.border = element_rect(color='black', fill=NA, linewidth=1),
      panel.grid.major = element_line(linewidth=0.25, color='lightgrey')
    ) + 
    xlab(bquote("Perturbation delta")) +
    ylab('Gain') + labs(color="")

pdf(paste0(fig_dir, 'tf_delta_', perturbation_name,'.pdf'), width=6, height=4)
p1 
dev.off()

```


Plot violin plots of some individual genes of interest 

```{r eval=FALSE}

cur_regulon <- subset(tf_regulons, tf == cur_tf)
cur_regulon_genes <- c( unique(cur_regulon$gene))
cur_regulon_genes <- cur_regulon_genes[cur_regulon_genes %in% tfnet_genes]

cur_regulon %>% slice_max(n=5, order_by = Gain*sign(Cor))
cur_regulon %>% slice_min(n=5, order_by = Gain*sign(Cor))

# group variable for vln plots
group.by <- 'pseudotime_bins_10'

# one of the hub genes to be perturbed
cur_gene <- cur_tf
target1 <- 'INSR'
target2 <- 'ERC2'




p1 <- VlnPlot(seurat_obj, features = cur_tf, pt.size=0.1, group.by = group.by, assay='RNA') +
  NoLegend() + xlab('') + ylab('') +  ylim(0,5) + 
  theme(
    axis.text.x = element_blank(),
    plot.margin=margin(c(0,0,0,0)) 
  ) + ggtitle(paste0(cur_tf, ' Observed'))

p2 <- VlnPlot(seurat_obj, features = cur_gene, pt.size=0.1, group.by = group.by, assay=perturbation_name) +
  NoLegend()  + ylab('') + ylim(0,5) + theme(
    plot.margin=margin(c(0,0,0,0))) + 
    ggtitle(paste0(cur_tf, ' Perturbed')) + 
    xlab('Pseudotime -->')

p3 <- VlnPlot(seurat_obj, features = target1, pt.size=0.1, group.by = group.by, assay='RNA') +
  NoLegend() + xlab('') + ylab('') +  ylim(0,5) + 
  theme(
    axis.text.x = element_blank(),
    plot.margin=margin(c(0,0,0,0)) 
  ) + ggtitle(paste0(target1, ' Observed'))

p4 <- VlnPlot(seurat_obj, features = target1, pt.size=0.1, group.by = group.by, assay=perturbation_name) +
  NoLegend()  + ylab('') + ylim(0,5) + theme(
    plot.margin=margin(c(0,0,0,0))) + 
    ggtitle(paste0(target1, ' Perturbed')) + 
    xlab('Pseudotime -->')


p5<- VlnPlot(seurat_obj, features = target2, pt.size=0.1, group.by = group.by, assay='RNA') +
  NoLegend() + xlab('') + ylab('') +  ylim(0,5) + 
  theme(
    axis.text.x = element_blank(),
    plot.margin=margin(c(0,0,0,0)) 
  ) + ggtitle(paste0(target2, ' Observed'))

p6 <- VlnPlot(seurat_obj, features = target2, pt.size=0.1, group.by = group.by, assay=perturbation_name) +
  NoLegend()  + ylab('') + ylim(0,5) + theme(
    plot.margin=margin(c(0,0,0,0))) + 
    ggtitle(paste0(target2, ' Perturbed')) + 
    xlab('Pseudotime -->')




pdf(paste0(fig_dir, 'vln_compare_', perturbation_name, '_', cur_gene, '.pdf'), width=18, height=4)
(p1 / p2) | (p3 / p4) | (p5 / p6)
dev.off()


```




TODO: Sort the TF regulons by pseudotime bins 

```{r eval=FALSE}



```



















GSEA 

```{r eval=FALSE}

library(magrittr)

################################################################
# Set up the Spi1 targets for GSEA:
################################################################

cur_tf <- 'SPI1'
cur_targets <- subset(tf_regulons, tf=cur_tf)
cur_targets$weight <- cur_targets$Gain * sign(cur_targets$Cor)
ranks <- cur_targets$weight; names(ranks) <- cur_targets$gene
ranks <- ranks[order(ranks)]

################################################################
# Run fgsea
################################################################

library(fgsea)
library(gggsea)

# load the GO Biological Pathways file (donwloaded from EnrichR website)
pathways <- gmtPathways('/dfs7/swaruplab/smorabit/resources/Enrichr/GO_Biological_Process_2021.txt')

# run fgsea to compute enrichments
fgseaRes <- fgsea(
  pathways = pathways, 
  stats    = ranks,
  minSize  = 15,
  maxSize  = 500
)


# # plot with gggsea 
# rl <- gggsea::myRankedlist #the sorted vector must be named! The names are gene IDs and the actual values are numbers (some metric, e.g. log2FC)
# setlist <- gggsea::mySetlist #this list must be named! Each list item is a vector of gene IDs

# print(head(rl))
# print(setlist)

# run the gggsea helper function to format the data 
# note that I had to make a slight modification to their function
# df <- gseaCurve(rl, setlist)

# helper function to wrap text
wrapText <- function(x, len) {
    sapply(x, function(y) paste(strwrap(y, len), collapse = "\n"), USE.NAMES = FALSE)
}

# rename the pathways in the fgseaRes table
tmp <- str_replace(names(pathways) , " \\s*\\([^\\)]+\\)", "")
Term <- wrapText(tmp, 40)
#names(pathways) <- Term


# select the pathways:
cur_pathways <- subset(fgseaRes, pval < 0.05)
dim(cur_pathways)

df <- gseaCurve(ranks, pathways[cur_pathways$pathway]) #, fgseaRes)

p <- ggplot2::ggplot() + 
  geom_gsea(df) 

pdf(paste0(fig_dir, 'test_fgsea.pdf'), width=16, height=10)
p
dev.off()


# dfList <- mapply(function(set, setname){
#   print(set)
#   if( sum(set %in% names(ranks))==0 ){
#     print("None of the genes in the ranked list are present in the set.")
#   } 
# }, set=pathways[1:5], setname=names(pathways)[1:5], SIMPLIFY=FALSE)



# df2 <- gseaCurve(rl, setlist, gsea)
# ggplot2::ggplot() + 
#   geom_gsea(df2) + 
#   theme_gsea(7)


```


Copy the gggsea functions and fix them lmao 

```{r eval=FALSE}

#' calculate coordinates for a GSEA plot
#'
#' Imports:
#' grDevices
#' dplyr
#'
#' @param rl named(!), sorted(!) vector. This ranked list's Values are the ranking metric (e.g. log2FC), names are the genes IDs. Gene IDs have to be of the same type as the ones in setList.
#' @param setlist named(!) list of character vectors. Each vector is a gene signature, each item in that vector is a gene ID (same type as the ones in rl!)
#' @param gsea data.frame with certain columns: pathway, pval, NES. The latter two will be printed on the GSEA plot.
#' @param weight number, the higher the more important are the changes at the extremes. 0: no weight, i.e. each found gene counts the same. 1: each gene counts according to its metric. 2: genes counts according to their squared matric, etc.
#' @return a data.frame with coordinates for a GSEA plot. When given as an input, geom_gsea will automatically take care. Otherwise: x and y plot the regular curve (geom_path); x, y1ticks and y2ticks plot the ticks (use geom_segment); color, x, xGradientStart, y1gradient and y2gradient for color bar (use geom_rect)
#' @details calculating the enrichment score at any given point follows standard rules. See for example https://www.pathwaycommons.org/guide/primers/data_analysis/gsea/
#' @export
#' @examples
#' library(gggsea)
#'
#' curve <- gseaCurve(myRankedlist, mySetlist)
#'
gseaCurve <- function(rl, setlist, gsea=NULL, weight=1){

  dfList <- mapply(function(set, setname){
   # print(set)
    #print(setname)
    if( sum(as.character(unlist(set)) %in% names(rl))==0 ){
      print("None of the genes in the ranked list are present in the set.")
      return(NULL)
    }

    # 0) reduce the set so that only genes are left that come up in the ranked list
    set <- set[set %in% names(rl)]

    # 1) a vector that has a number for each gene in the ranked list: 0 if not in the set, and its metric (adjusted by a defined weight) if it is in the set.
    presence <- rep(0,length(rl))
    positions <- which(names(rl) %in% set)
    presence[positions] <- abs(rl[positions])^weight

    # 2) a similar vector, except it has a 1 for every gene NOT in the list, and a 0 for everything else.
    absence <- rep(1,length(rl))
    absence[positions] <- 0

    # 3) calculate the relative cumulative increase for presence and absence
    cumPresence <- cumsum(presence)
    relPresence <- sapply(cumPresence, function(x) x/max(cumPresence)) #stepwise increase for presence
    relAbsence <- cumsum(absence) / (length(rl) - length(set)) #stepwise increase for absence

    # 4) subtract the cumulative absence from the cumulative presence to get the enrichment score
    es <- relPresence-relAbsence #enrichment score
    xcoord <- seq_along(es)

    ## the data.frame df will contain everything for the GSEAplot. For now it just contains the actual curve
    df <- data.frame(x = c(0,xcoord), y = c(0,es), set = setname, gene=c(0, names(rl)) )

    maxES <- max(df$y)
    minES <- min(df$y)
    sizeFactor <- abs(maxES - minES)
    lowestPoint <- minES - sizeFactor / 30
    df$bottomline <- lowestPoint
    df$zeroline <- median(which(rl==sort(abs(rl))[1]))

    #=======================================================
    # add statistics =======================================================
    # label will initially be empty and only be filled if gsea was provided
    statdf <- data.frame(x = 0,
                         ystat = lowestPoint+sizeFactor*.02,
                         stattext = NA )

    if(!is.null(gsea)){
      subgsea <- gsea[gsea$pathway %in% setname,]
      statdf$stattext = paste0("atop(italic(NES)==",as.character(round(subgsea$NES, 2)),
                               ",italic(p)==",      as.character(round(subgsea$pval,4)),")")
    }
    df <- merge(df, statdf, by="x", all=T) #merge the dataframe with the statistics (will add statistics coordinates and label only to the first row (x=0))

    #=======================================================
    # add ticks =======================================================
    df <- merge(df, .presenceTicks(rl, set, lowestPoint, sizeFactor), by="x", all=TRUE)
    lowestPoint <- min(df$y2ticks, na.rm=TRUE) # lowest point is changed for the color gradient

    #=======================================================
    # add color gradient =======================================================
    df <- merge(df, .colorGradient(rl, lowestPoint, sizeFactor), by="x", all=TRUE)

    return(df)

  }, set=setlist, setname=names(setlist), SIMPLIFY=FALSE)

  df <- do.call(rbind, dfList) # combine all df's (were calculated separately for each set)

  return(df)
}

#========================================
# calculate ticks
.presenceTicks <- function(rl, set, lowestPoint, sizeFactor){

  ticks <- data.frame(x = which(names(rl) %in% set),
                      y1ticks = lowestPoint - sizeFactor / 40,
                      y2ticks = lowestPoint - sizeFactor / 8,
                      hitgene = names(rl[names(rl) %in% set]))

  return(ticks)
}

#========================================
# calculate the color gradient
.colorGradient <- function(rl, lowestPoint, sizeFactor, lowcol="blue", midcol="white", highcol="red", resolution=20){

  # 1) create a data.frame that will eventually hold the plotting values. Start with a sequence from -max to +max of the ranked list's metric
  gradient <- unlist(lapply(seq(0,1,length.out=resolution/2+1), function(x) dplyr::nth(sort(abs(rl)), as.integer(length(rl)*x)) ))
  gradient <- gradient[-1]
  gradient <- sort(c(gradient,-gradient))
  gradient <- data.frame(valueMax=gradient[-1])

  # 2) add color values to the table that correspond to the metric
  colfunc1 <- grDevices::colorRampPalette(c(highcol, midcol)) #functions for getting a color ramp
  colfunc2 <- grDevices::colorRampPalette(c(midcol, lowcol))
  gradient$color <- c(colfunc1(resolution/2), colfunc2(resolution/2)[-1])

  # 3) the x columns will contain the number of genes that contain a value <= than the one in the current row. Know we know where each color starts and ends
  #(the x axis will be as long as the number of genes in the ranked list, therefore the number of genes with a metric smaller than the one that stands for a color defines how long-stretched this color will be)
  gradient$x <- sapply( gradient$valueMax, function(x) sum(rl <= x) )
  gradient <- gradient[!duplicated(gradient$x),]
  gradient$xGradientStart <- c( 1, gradient$x[-nrow(gradient)] )
  #gradient <- gradient[-nrow(gradient),]

  # 4) add y column, which will be the same for all. The y position will only be influenced by the ES values (i.e. where the curve is)
  gradient$y1gradient <- lowestPoint #multiplying by the sizefactor is necessary to keep the gradient height and position the same in every graph
  gradient$y2gradient <- lowestPoint - sizeFactor / 8

  return(gradient)
}

```

